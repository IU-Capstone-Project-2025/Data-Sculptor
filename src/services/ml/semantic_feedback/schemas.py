"""Module for defining API schemas for the feedback service.

This module contains Pydantic models used for request and response
data validation in the FastAPI application.

Public API:
    - HealthCheckResponse: Schema for the health check endpoint.
    - FeedbackResponse: Schema for the feedback endpoint response.
"""

from pydantic import BaseModel, Field, UUID4
from typing import Literal


class HealthCheckResponse(BaseModel):
    """Response model for the health check endpoint."""

    status: str = Field(..., example="ok")


class Position(BaseModel):
    """Represents a position in a text document (zero-based).

    The ``character`` field is intentionally excluded from the JSON schema used
    for LLM structured output to simplify the model's job â€“ it only needs to
    supply a ``line`` number. We still keep ``character`` at runtime so the
    service can populate it after post-processing.
    """

    line: int = Field(..., ge=0, description="Zero-based line index.")
    character: int = Field(0, description="Zero-based character offset.")


class Range(BaseModel):
    """A range in a text document expressed as (start, end) positions."""

    start: Position
    end: Position


class LocalizedWarning(BaseModel):
    """Schema for an individual LSP warning generated by the service."""

    range: Range
    severity: Literal[2] = 2
    code: Literal["custom-warning"] = "custom-warning"
    source: Literal["Data Sculptor"] = "Data Sculptor"
    message: str


class FeedbackResponse(BaseModel):
    """Response model for the feedback endpoint."""

    non_localized_feedback: str = Field(
        ...,
        example="The notebook provides a good starting point for analysis.",
    )
    localized_feedback: list[LocalizedWarning] = Field(default_factory=list)


class FeedbackRequest(BaseModel):
    current_code: str = Field(..., description="Code snippet to analyse.")
    cell_code_offset: int = Field(
        0, ge=0, description="Global line offset of the snippet in the full notebook."
    )
    section_index: int = Field(
        ..., ge=0, description="Identifier of section to validate."
    )
    case_id: UUID4 = Field(
        ..., description="Identifier of the case to validate against."
    )
    use_deep_analysis: bool = Field(
        default=True, description="Whether to use deep analysis."
    )


class MLScentWarningItem(BaseModel):
    """Input schema for a single high-level warning description from MLScent."""

    description: str = Field(..., description="Warning description.")
    framework: str = Field(..., description="Associated ML/DS framework.")
    fix: str = Field(..., description="Suggested fix for the warning.")
    benefit: str = Field(..., description="Benefit gained by applying the fix.")

    def get_llm_description(self) -> str:
        fix = f"How to fix: {self.fix}" if self.fix != "Not specified" else ""
        benefit = f"Benefits: {self.benefit}" if self.benefit != "Not specified" else ""
        return f"Description: {self.description}\nFramework: {self.framework}\n{fix}\n{benefit}"


class MLScentLocalizationRequest(BaseModel):
    """Request model for localising warnings into code positions."""

    current_code: str = Field(..., description="Code snippet to analyse.")
    warnings: list[MLScentWarningItem] = Field(
        ..., description="List of high-level warning objects to be localised."
    )
    cell_code_offset: int | None = Field(
        0,
        ge=0,
        description="Global line offset of the snippet in the full notebook (optional).",
    )
    use_deep_analysis: bool = Field(
        default=False, description="Whether to use deep analysis."
    )


class MLScentLocalizationResponse(BaseModel):
    """Response model containing localised warnings in LSP format."""

    localized_feedback: list[LocalizedWarning] = Field(default_factory=list)
